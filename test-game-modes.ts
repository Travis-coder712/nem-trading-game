/**
 * Comprehensive Game Mode Test Script
 * Tests all 5 game modes end-to-end with battery mechanics and pro-rata dispatch verification.
 *
 * Run: npx tsx test-game-modes.ts
 */

import { GameEngine } from './server/engine/GameEngine.ts';
import type { GameMode, AssetBid, BidBand, TimePeriod } from './shared/types.ts';

const engine = new GameEngine();

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let passed = 0;
let failed = 0;
const failures: string[] = [];

function assert(condition: boolean, message: string) {
  if (condition) {
    passed++;
  } else {
    failed++;
    failures.push(message);
    console.error(`  âœ— FAIL: ${message}`);
  }
}

function section(title: string) {
  console.log(`\n${'â•'.repeat(60)}`);
  console.log(`  ${title}`);
  console.log('â•'.repeat(60));
}

function subsection(title: string) {
  console.log(`\n  â”€â”€ ${title} â”€â”€`);
}

/**
 * Create a game, add teams, and play through ALL rounds with default bids.
 * Returns the final game state for assertions.
 */
function playFullGame(mode: GameMode, teamCount: number = 3) {
  const game = engine.createGame(mode, teamCount, false, true);
  assert(game !== null && game !== undefined, `${mode}: Game created`);
  assert(game.phase === 'lobby', `${mode}: Initial phase is lobby`);

  // Add teams
  const teams = [];
  for (let i = 0; i < teamCount; i++) {
    const team = engine.addTeam(game.id, `Team ${String.fromCharCode(65 + i)}`, `socket-${i}`);
    assert(team !== null && !('error' in (team as any)), `${mode}: Team ${i + 1} added`);
    teams.push(team);
  }

  const totalRounds = game.config.rounds.length;
  console.log(`  Playing ${totalRounds} rounds with ${teamCount} teams...`);

  const roundResults = [];
  let batteryRoundFound = false;
  let batteryMiniGameRound = -1;

  for (let r = 0; r < totalRounds; r++) {
    const roundConfig = engine.startRound(game.id);
    assert(roundConfig !== null, `${mode} R${r + 1}: startRound succeeded`);
    if (!roundConfig) break;

    assert(game.phase === 'briefing', `${mode} R${r + 1}: Phase is briefing after startRound`);

    // Check battery mini-game flag
    if ((roundConfig as any).batteryMiniGame) {
      batteryMiniGameRound = r + 1;
      console.log(`  ğŸ“‹ Round ${r + 1} has batteryMiniGame flag`);
    }

    // Check if battery assets exist this round
    const hasBattery = game.teams.some(t =>
      t.assets.some(a => a.assetDefinitionId.includes('battery'))
    );
    if (hasBattery && !batteryRoundFound) {
      batteryRoundFound = true;
      console.log(`  ğŸ”‹ Battery first available in Round ${r + 1}`);
    }

    // Verify demand was generated
    for (const period of roundConfig.timePeriods) {
      const demand = roundConfig.baseDemandMW[period];
      assert(demand > 0, `${mode} R${r + 1} ${period}: Demand > 0 (got ${Math.round(demand)} MW)`);
    }

    // Verify assets assigned to teams
    for (const team of game.teams) {
      assert(team.assets.length > 0, `${mode} R${r + 1}: ${team.name} has assets (${team.assets.length})`);
    }

    // Start bidding (default bids will be generated by dispatch)
    engine.startBidding(game.id);
    assert(game.phase === 'bidding', `${mode} R${r + 1}: Phase is bidding`);

    // Run dispatch (generates default bids for all teams)
    const result = engine.runDispatch(game.id);
    assert(result !== null, `${mode} R${r + 1}: runDispatch succeeded`);
    if (!result) break;

    assert(game.phase === 'results', `${mode} R${r + 1}: Phase is results after dispatch`);
    assert(result.periodResults.length === roundConfig.timePeriods.length,
      `${mode} R${r + 1}: Got ${result.periodResults.length} period results (expected ${roundConfig.timePeriods.length})`);
    assert(result.teamResults.length === teamCount,
      `${mode} R${r + 1}: Got ${result.teamResults.length} team results (expected ${teamCount})`);

    // Verify clearing prices are within bounds
    for (const pr of result.periodResults) {
      assert(pr.clearingPriceMWh >= -1000, `${mode} R${r + 1} ${pr.timePeriod}: Clearing price >= floor (${pr.clearingPriceMWh.toFixed(2)})`);
      assert(pr.clearingPriceMWh <= 20000, `${mode} R${r + 1} ${pr.timePeriod}: Clearing price <= cap (${pr.clearingPriceMWh.toFixed(2)})`);
      assert(pr.totalDispatchedMW >= 0, `${mode} R${r + 1} ${pr.timePeriod}: Dispatched MW >= 0`);
    }

    // Verify team results have valid profit numbers
    for (const tr of result.teamResults) {
      assert(typeof tr.totalProfitDollars === 'number' && !isNaN(tr.totalProfitDollars),
        `${mode} R${r + 1}: ${tr.teamName} profit is valid number (${tr.totalProfitDollars.toFixed(0)})`);
      assert(typeof tr.totalRevenueDollars === 'number' && !isNaN(tr.totalRevenueDollars),
        `${mode} R${r + 1}: ${tr.teamName} revenue is valid number`);
    }

    roundResults.push(result);
  }

  return { game, roundResults, batteryRoundFound, batteryMiniGameRound };
}


// â”€â”€â”€ Test 1: Quick Game Mode (8 rounds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 1: Quick Game Mode');
{
  const { game, roundResults, batteryRoundFound, batteryMiniGameRound } = playFullGame('quick', 3);

  assert(game.config.rounds.length === 8, 'Quick Game: 8 rounds configured');
  assert(roundResults.length === 8, 'Quick Game: 8 rounds completed');
  assert(batteryRoundFound, 'Quick Game: Battery assets available at some point');
  assert(batteryMiniGameRound === 5, `Quick Game: Battery mini-game in Round 5 (got ${batteryMiniGameRound})`);

  // Check final standings
  const sortedTeams = [...game.teams].sort((a, b) => b.cumulativeProfitDollars - a.cumulativeProfitDollars);
  console.log(`  Final standings:`);
  sortedTeams.forEach(t => console.log(`    ${t.rank}. ${t.name}: $${t.cumulativeProfitDollars.toLocaleString()}`));

  assert(game.roundResults.length === 8, 'Quick Game: All round results stored');
  console.log('  âœ“ Quick Game mode completed successfully');
}


// â”€â”€â”€ Test 2: Progressive Learning Mode (10 rounds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 2: Progressive Learning Mode');
{
  const { game, roundResults, batteryRoundFound, batteryMiniGameRound } = playFullGame('progressive', 3);

  assert(game.config.rounds.length === 10, 'Progressive: 10 rounds configured');
  assert(roundResults.length === 10, 'Progressive: 10 rounds completed');
  assert(batteryRoundFound, 'Progressive: Battery assets available at some point');
  assert(batteryMiniGameRound === 6, `Progressive: Battery mini-game in Round 6 (got ${batteryMiniGameRound})`);

  // Verify progressive asset unlocking
  // Round 1 should have fewer assets than Round 10
  const r1Assets = game.roundResults[0]?.teamResults[0];
  const r10Assets = game.roundResults[9]?.teamResults[0];
  console.log(`  Round 1 team profit: $${r1Assets?.totalProfitDollars?.toFixed(0)}`);
  console.log(`  Round 10 team profit: $${r10Assets?.totalProfitDollars?.toFixed(0)}`);

  console.log('  âœ“ Progressive Learning mode completed successfully');
}


// â”€â”€â”€ Test 3: Full Game Mode (15 rounds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 3: Full Game Mode');
{
  const { game, roundResults, batteryRoundFound, batteryMiniGameRound } = playFullGame('full', 3);

  assert(game.config.rounds.length === 15, 'Full Game: 15 rounds configured');
  assert(roundResults.length === 15, 'Full Game: 15 rounds completed');
  assert(batteryRoundFound, 'Full Game: Battery assets available at some point');
  assert(batteryMiniGameRound === 8, `Full Game: Battery mini-game in Round 8 (got ${batteryMiniGameRound})`);

  console.log('  âœ“ Full Game mode completed successfully');
}


// â”€â”€â”€ Test 4: Experienced Replay Mode (4 rounds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 4: Experienced Replay Mode');
{
  const { game, roundResults, batteryRoundFound } = playFullGame('experienced', 3);

  assert(game.config.rounds.length === 4, 'Experienced: 4 rounds configured');
  assert(roundResults.length === 4, 'Experienced: 4 rounds completed');
  assert(batteryRoundFound, 'Experienced: Battery assets available (full portfolio from start)');

  // Verify scenario events are present in each round
  const roundNames = game.config.rounds.map(r => r.name);
  console.log(`  Rounds: ${roundNames.join(' | ')}`);

  console.log('  âœ“ Experienced Replay mode completed successfully');
}


// â”€â”€â”€ Test 5: Beginner Mode (1 round) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 5: Beginner Mode');
{
  const { game, roundResults, batteryRoundFound } = playFullGame('beginner', 2);

  assert(game.config.rounds.length === 1, 'Beginner: 1 round configured');
  assert(roundResults.length === 1, 'Beginner: 1 round completed');
  assert(!batteryRoundFound, 'Beginner: No battery assets (coal + gas only)');

  console.log('  âœ“ Beginner mode completed successfully');
}


// â”€â”€â”€ Test 6: Pro-Rata Dispatch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 6: Pro-Rata Dispatch Verification');
{
  subsection('Same-price bids should be dispatched proportionally');

  const game = engine.createGame('quick', 2, false, true);
  engine.addTeam(game.id, 'Alpha', 'sock-a');
  engine.addTeam(game.id, 'Beta', 'sock-b');

  const roundConfig = engine.startRound(game.id);
  assert(roundConfig !== null, 'Pro-rata: Round started');

  engine.startBidding(game.id);

  // Manually submit bids: both teams bid same price for coal in first period
  const period = roundConfig!.timePeriods[0] as TimePeriod;
  const teamA = game.teams[0];
  const teamB = game.teams[1];

  // Find coal assets for each team
  const teamACoal = teamA.assets.find(a => a.assetDefinitionId.includes('coal'));
  const teamBCoal = teamB.assets.find(a => a.assetDefinitionId.includes('coal'));
  assert(!!teamACoal, 'Pro-rata: Team A has coal asset');
  assert(!!teamBCoal, 'Pro-rata: Team B has coal asset');

  if (teamACoal && teamBCoal) {
    const bidPrice = 50; // Same price for both teams
    const teamAMW = teamACoal.currentAvailableMW;
    const teamBMW = teamBCoal.currentAvailableMW;

    // Create bids for ALL assets and ALL periods (to avoid default bid generation issues)
    const createBidsForTeam = (team: typeof teamA, teamId: string) => {
      const bids: AssetBid[] = [];
      for (const p of roundConfig!.timePeriods) {
        for (const asset of team.assets) {
          const isBattery = asset.assetDefinitionId.includes('battery');
          bids.push({
            assetInstanceId: asset.id,
            assetDefinitionId: asset.assetDefinitionId,
            teamId: teamId,
            timePeriod: p as TimePeriod,
            bands: isBattery ? [] : [{ pricePerMWh: bidPrice, quantityMW: asset.currentAvailableMW }],
            totalOfferedMW: isBattery ? 0 : asset.currentAvailableMW,
            batteryMode: isBattery ? 'idle' : undefined,
            submittedAt: Date.now(),
          });
        }
      }
      return bids;
    };

    engine.submitBids(game.id, {
      teamId: teamA.id,
      roundNumber: 1,
      bids: createBidsForTeam(teamA, teamA.id),
      isComplete: true,
    });

    engine.submitBids(game.id, {
      teamId: teamB.id,
      roundNumber: 1,
      bids: createBidsForTeam(teamB, teamB.id),
      isComplete: true,
    });

    const result = engine.runDispatch(game.id);
    assert(result !== null, 'Pro-rata: Dispatch completed');

    if (result) {
      // Check first period â€” with same-price bids, if demand < total supply, both should get partial
      const pr = result.periodResults[0];
      console.log(`  Period: ${pr.timePeriod}, Demand: ${pr.demandMW} MW, Clearing: $${pr.clearingPriceMWh.toFixed(2)}/MWh`);

      // Find dispatched bands for each team's coal
      const teamABands = pr.meritOrderStack.filter(b => b.teamId === teamA.id && b.assetDefinitionId.includes('coal'));
      const teamBBands = pr.meritOrderStack.filter(b => b.teamId === teamB.id && b.assetDefinitionId.includes('coal'));

      const teamADispatched = teamABands.reduce((sum, b) => sum + b.dispatchedMW, 0);
      const teamBDispatched = teamBBands.reduce((sum, b) => sum + b.dispatchedMW, 0);

      console.log(`  Team A coal dispatched: ${teamADispatched.toFixed(1)} MW (offered ${teamAMW})`);
      console.log(`  Team B coal dispatched: ${teamBDispatched.toFixed(1)} MW (offered ${teamBMW})`);

      // If both offered same price and there's excess supply, pro-rata should give proportional dispatch
      const totalOffered = teamAMW + teamBMW;
      if (pr.demandMW < totalOffered) {
        // Pro-rata: ratio should be similar to offered capacity ratio
        const expectedRatioA = teamAMW / totalOffered;
        const actualRatioA = teamADispatched / (teamADispatched + teamBDispatched || 1);
        console.log(`  Expected ratio A: ${(expectedRatioA * 100).toFixed(1)}%, Actual: ${(actualRatioA * 100).toFixed(1)}%`);
        assert(Math.abs(expectedRatioA - actualRatioA) < 0.05,
          `Pro-rata: Dispatch ratio matches capacity ratio (diff: ${Math.abs(expectedRatioA - actualRatioA).toFixed(3)})`);
      } else {
        console.log(`  Demand (${pr.demandMW}) >= total offered (${totalOffered}), both fully dispatched`);
        assert(teamADispatched > 0 && teamBDispatched > 0, 'Pro-rata: Both teams dispatched when demand exceeds supply');
      }

      // Verify both teams got dispatched (not one fully and one not)
      assert(teamADispatched > 0, 'Pro-rata: Team A got dispatched');
      assert(teamBDispatched > 0, 'Pro-rata: Team B got dispatched');
    }
  }

  console.log('  âœ“ Pro-rata dispatch test completed');
}


// â”€â”€â”€ Test 7: Battery Mechanics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 7: Battery Mechanics Verification');
{
  subsection('Battery charge/discharge/idle modes');

  const game = engine.createGame('experienced', 2, false, true);
  engine.addTeam(game.id, 'BattTest A', 'sock-ba');
  engine.addTeam(game.id, 'BattTest B', 'sock-bb');

  const roundConfig = engine.startRound(game.id);
  assert(roundConfig !== null, 'Battery: Round started');

  engine.startBidding(game.id);

  const team = game.teams[0];
  const battery = team.assets.find(a => a.assetDefinitionId.includes('battery'));
  assert(!!battery, 'Battery: Battery asset found in experienced mode');

  if (battery) {
    console.log(`  Battery: ${battery.assetDefinitionId}`);
    console.log(`  Capacity: ${battery.currentAvailableMW} MW`);
    console.log(`  Storage: ${battery.currentStorageMWh} / ${battery.maxStorageMWh} MWh`);

    assert(battery.currentAvailableMW === 500, `Battery: Capacity is 500 MW (got ${battery.currentAvailableMW})`);
    assert(battery.maxStorageMWh === 2000, `Battery: Max storage is 2000 MWh (got ${battery.maxStorageMWh})`);

    // SOC should be random 20-80%
    const socPercent = (battery.currentStorageMWh! / battery.maxStorageMWh!) * 100;
    assert(socPercent >= 15 && socPercent <= 85, `Battery: Initial SOC in reasonable range (${socPercent.toFixed(0)}%)`);

    // Create bids with battery in charge mode for first period, discharge for second
    const periods = roundConfig!.timePeriods;
    const bids: AssetBid[] = [];

    for (const p of periods) {
      for (const asset of team.assets) {
        const isBattery = asset.assetDefinitionId.includes('battery');

        if (isBattery) {
          const periodIdx = periods.indexOf(p);
          let batteryMode: 'charge' | 'discharge' | 'idle';
          let chargeMW = 0;
          let bands: BidBand[] = [];

          if (periodIdx === 0) {
            // Charge in first period
            batteryMode = 'charge';
            chargeMW = 200; // Charge at 200 MW
          } else if (periodIdx === periods.length - 1) {
            // Discharge in last period
            batteryMode = 'discharge';
            bands = [{ pricePerMWh: 0, quantityMW: 200 }]; // Bid to discharge 200 MW
          } else {
            batteryMode = 'idle';
          }

          bids.push({
            assetInstanceId: asset.id,
            assetDefinitionId: asset.assetDefinitionId,
            teamId: team.id,
            timePeriod: p as TimePeriod,
            bands,
            totalOfferedMW: batteryMode === 'discharge' ? 200 : 0,
            batteryMode,
            chargeMW: batteryMode === 'charge' ? chargeMW : undefined,
            isBatteryCharging: batteryMode === 'charge',
            submittedAt: Date.now(),
          });
        } else {
          // Non-battery assets: bid at $0 to guarantee dispatch
          bids.push({
            assetInstanceId: asset.id,
            assetDefinitionId: asset.assetDefinitionId,
            teamId: team.id,
            timePeriod: p as TimePeriod,
            bands: [{ pricePerMWh: 0, quantityMW: asset.currentAvailableMW }],
            totalOfferedMW: asset.currentAvailableMW,
            submittedAt: Date.now(),
          });
        }
      }
    }

    engine.submitBids(game.id, {
      teamId: team.id,
      roundNumber: 1,
      bids,
      isComplete: true,
    });

    // Let Team B use default bids
    const result = engine.runDispatch(game.id);
    assert(result !== null, 'Battery: Dispatch completed');

    if (result) {
      // Check that team results exist and have battery-related fields
      const teamResult = result.teamResults.find(r => r.teamId === team.id);
      assert(!!teamResult, 'Battery: Team result found');

      if (teamResult) {
        console.log(`  Total Revenue: $${teamResult.totalRevenueDollars.toFixed(0)}`);
        console.log(`  Total Cost: $${teamResult.totalCostDollars.toFixed(0)}`);
        console.log(`  Total Profit: $${teamResult.totalProfitDollars.toFixed(0)}`);
        assert(typeof teamResult.totalProfitDollars === 'number' && !isNaN(teamResult.totalProfitDollars),
          'Battery: Profit calculated correctly');

        // Check period results for charging load
        const firstPeriod = result.periodResults[0];
        console.log(`  First period charging load: ${firstPeriod.totalChargingLoadMW || 0} MW`);
      }
    }
  }

  console.log('  âœ“ Battery mechanics test completed');
}


// â”€â”€â”€ Test 8: Asset Configuration Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 8: Asset Configuration Check');
{
  subsection('Verify battery specs across modes');

  for (const mode of ['quick', 'full', 'progressive', 'experienced'] as GameMode[]) {
    const game = engine.createGame(mode, 2, false, true);
    engine.addTeam(game.id, 'Check Team', 'sock-check');
    engine.addTeam(game.id, 'Other Team', 'sock-other');

    // Start enough rounds to get battery
    let hasBattery = false;
    const totalRounds = game.config.rounds.length;
    for (let r = 0; r < totalRounds && !hasBattery; r++) {
      engine.startRound(game.id);
      engine.startBidding(game.id);

      const team = game.teams[0];
      const battery = team.assets.find(a => a.assetDefinitionId.includes('battery'));
      if (battery) {
        hasBattery = true;
        assert(battery.currentAvailableMW === 500, `${mode}: Battery is 500 MW (got ${battery.currentAvailableMW})`);
        assert(battery.maxStorageMWh === 2000, `${mode}: Battery is 2000 MWh (got ${battery.maxStorageMWh})`);
        console.log(`  ${mode}: Battery found in Round ${r + 1} â€” ${battery.currentAvailableMW} MW / ${battery.maxStorageMWh} MWh âœ“`);
      }

      engine.runDispatch(game.id);
    }

    if (mode !== 'beginner') {
      assert(hasBattery, `${mode}: Battery eventually available`);
    }
  }

  console.log('  âœ“ Asset configuration validated across all modes');
}


// â”€â”€â”€ Test 9: Game with Many Teams â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST 9: Scalability â€” 15 Team Quick Game');
{
  const { game, roundResults } = playFullGame('quick', 15);
  assert(game.teams.length === 15, '15-team: All teams joined');
  assert(roundResults.length === 8, '15-team: All 8 rounds completed');

  // Verify all teams have results
  const finalResults = roundResults[roundResults.length - 1];
  assert(finalResults.teamResults.length === 15, '15-team: All teams have final results');

  // Verify pro-rata works with many teams at same price
  console.log(`  15 teams completed 8 rounds successfully`);
  console.log('  âœ“ Scalability test passed');
}


// â”€â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

section('TEST RESULTS SUMMARY');
console.log(`  âœ“ Passed: ${passed}`);
console.log(`  âœ— Failed: ${failed}`);
if (failures.length > 0) {
  console.log(`\n  Failures:`);
  failures.forEach(f => console.log(`    - ${f}`));
}
console.log(`\n  Total assertions: ${passed + failed}`);
console.log(failed === 0 ? '\n  ğŸ‰ ALL TESTS PASSED!' : '\n  âŒ SOME TESTS FAILED');
process.exit(failed > 0 ? 1 : 0);
